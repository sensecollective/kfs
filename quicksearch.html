<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"lib_b-table.js.html":{"id":"lib_b-table.js.html","title":"Source: lib/b-table.js","body":" KFS Modules kfskfs/constantskfs/utils Classes BtableReadableFileStreamSbucketWritableFileStream Events ReadableFileStream#event:dataReadableFileStream#event:endReadableFileStream#event:errorReadableFileStream#event:readableSbucket#event:closeSbucket#event:idleSbucket#event:openWritableFileStream#event:errorWritableFileStream#event:finish Tutorials Command Line InterfaceProgrammatic UsagePerformance Testing the Changes Source: lib/b-table.js 'use strict'; var inherits = require('util').inherits; var merge = require('merge'); var events = require('events'); var fs = require('fs'); var mkdirp = require('mkdirp'); var utils = require('./utils'); var constants = require('./constants'); var Sbucket = require('./s-bucket'); var path = require('path'); var assert = require('assert'); var async = require('async'); /** * A series of {@link Sbucket}s composing a sharded table * @constructor * @param {String} tablePath - The path to the directory to store the table * @param {Object} [options] * @param {String} [options.referenceId] - R bit hex reference ID * @param {Number} [options.maxTableSize] - Max bytes to cap the database * @param {Object} [options.sBucketOpts] - Options to pass to Sbucket creation */ function Btable(tablePath, options) { if (!(this instanceof Btable)) { return new Btable(tablePath, options); } events.EventEmitter.call(this); this._options = merge(Object.create(Btable.DEFAULTS), options); this._rid = utils.createReferenceId(this._options.referenceId); this._sBuckets = {}; this._tablePath = utils.coerceTablePath(tablePath); this._maxTableSize = this._options.maxTableSize; this._options.sBucketOpts.maxSize = this._maxTableSize / constants.B; this._open(); } inherits(Btable, events.EventEmitter); Btable.RID_FILENAME = 'r.id'; Btable.DEFAULTS = { referenceId: null, maxTableSize: constants.S * constants.B, sBucketOpts: {} }; /** * Opens the Btable, creating it if it does not exist * @private */ Btable.prototype._open = function() { if (!utils.fileDoesExist(this._tablePath)) { this._initBtableDirectory(); } else { this._validateTablePath(); } this._rid = Buffer(fs.readFileSync( path.join(this._tablePath, Btable.RID_FILENAME), { encoding: 'hex' } ), 'hex'); }; /** * Initializes a new KFS database (B-table directory) * @private */ Btable.prototype._initBtableDirectory = function() { mkdirp.sync(this._tablePath); fs.writeFileSync( path.join(this._tablePath, Btable.RID_FILENAME), this._rid, { encoding: 'hex' } ); }; /** * Validates a path to a directory as a KFS instance * @private */ Btable.prototype._validateTablePath = function() { var dirStats = fs.statSync(this._tablePath); assert(dirStats.isDirectory(), 'Table path is not a directory'); var requiredPaths = [Btable.RID_FILENAME]; var dirContents = fs.readdirSync(this._tablePath); for (var i = 0; i &lt; requiredPaths.length; i++) { assert( dirContents.indexOf(requiredPaths[i]) !== -1, 'Table path is not a valid KFS instance' ); } }; /** * Determine the {@link Sbucket} index for a given key * @private * @param {String} key - The data key to route * @returns {Number} */ Btable.prototype._getSbucketIndexForKey = function(key) { return this._rid[0] ^ Buffer(utils.hashKey(key), 'hex')[0]; }; /** * Get the {@link Sbucket} for the supplied index * @private * @param {Number} sBucketIndex - The index for the desired bucket * @returns {Sbucket} */ Btable.prototype._getSbucketAtIndex = function(sBucketIndex) { assert(sBucketIndex &lt; constants.B, 'Index must not be greater than B'); assert(sBucketIndex &gt; -1, 'Index must be greater than or equal to 0'); if (this._sBuckets[sBucketIndex]) { return this._sBuckets[sBucketIndex]; } this._sBuckets[sBucketIndex] = new Sbucket( path.join(this._tablePath, utils.createSbucketNameFromIndex(sBucketIndex)), this._options.sBucketOpts ); this._sBuckets[sBucketIndex].removeAllListeners('idle'); this._sBuckets[sBucketIndex].on('idle', function() { this.close(); }); return this._sBuckets[sBucketIndex]; }; /** * Get the {@link Sbucket} for the given key * @private * @param {String} key - The key that maps to a {@link Sbucket} * @param {Btable~_getSbucketForKeyCallback} */ Btable.prototype._getSbucketForKey = function(key, callback) { var sIndex = typeof key === 'number' ? key : this._getSbucketIndexForKey(key); var sBucket = this._getSbucketAtIndex(sIndex); if (sBucket.readyState !== Sbucket.OPENED) { return sBucket.open(function(err) { if (err) { return callback(err); } callback(null, sBucket, sIndex); }); } callback(null, sBucket, sIndex); }; /** * @private * @callback Btable~_getSbucketForKeyCallback * @param {Error} [error] * @param {Sbucket} sBucket */ /** * Lists the created {@link Sbucket}s and their sizes * @param {String|Number} [keyOrIndex] - Optional bucket index or file key * @param {Btable~statCallback} */ Btable.prototype.stat = function(keyOrIndex, callback) { var self = this; if (typeof keyOrIndex === 'function') { callback = keyOrIndex; keyOrIndex = null; } if (keyOrIndex) { return _getStat(keyOrIndex, function(err, stats) { callback(err, stats ? [stats] : undefined); }); } var sBuckets = fs.readdirSync(this._tablePath).filter(function(name) { return name !== Btable.RID_FILENAME; }).map(function(sBucketName) { return parseInt(sBucketName); }); function _getStat(sBucketIndex, done) { var key = utils.coerceKeyOrIndex(sBucketIndex); self._getSbucketForKey(key, function(err, sBucket, sIndex) { if (err) { return done(err); } sBucket.stat(function(err, stats) { if (err) { return done(err); } done(null, { sBucketIndex: sIndex, sBucketStats: stats }); }); }); } async.mapLimit(sBuckets, 3, _getStat, callback); }; /** * @callback Btable~statCallback * @param {Error} [error] * @param {Object[]} sBuckets * @param {String} sBuckets[].sBucketIndex - The index of the S-bucket * @param {Object} sBuckets[].sBucketStats * @param {Number} sBuckets[].sBucketStats.used - Space used in the bucket * @param {Number} sBuckets[].sBucketStats.free - Space free in the bucket */ /** * Lists the file keys in the given bucket * @param {Number|String} keyOrIndex - The bucket index of a file key * @param {Sbucket~listCallback} */ Btable.prototype.list = function(keyOrIndex, callback) { var key = utils.coerceKeyOrIndex(keyOrIndex); this._getSbucketForKey(key, function(err, sBucket) { if (err) { return callback(err); } sBucket.list(callback); }); }; /** * Check if a file exists at the supplied key * @param {String} key - The key to check for existence * @param {Sbucket~existsCallback} */ Btable.prototype.exists = function(key, callback) { this._getSbucketForKey(key, function(err, sBucket) { if (err) { return callback(err); } sBucket.exists(key, callback); }); }; /** * Unlinks the data for the given key * @param {String} key - The key to unlink data from * @param {Sbucket~unlinkCallback} */ Btable.prototype.unlink = function(key, callback) { this._getSbucketForKey(key, function(err, sBucket) { if (err) { return callback(err); } sBucket.unlink(key, callback); }); }; /** * Reads the data at the supplied key into a buffer * @param {String} key - The key for the data to read * @param {Sbucket~readFileCallback} */ Btable.prototype.readFile = function(key, callback) { this._getSbucketForKey(key, function(err, sBucket) { if (err) { return callback(err); } sBucket.readFile(key, callback); }); }; /** * Creates a readable stream of the data at the given key * @param {String} key - The key for the data read * @param {Btable~createReadStreamCallback} */ Btable.prototype.createReadStream = function(key, callback) { this._getSbucketForKey(key, function(err, sBucket) { if (err) { return callback(err); } callback(null, sBucket.createReadStream(key)); }); }; /** * @callback Btable~createReadStreamCallback * @param {Error} [error] * @param {ReadableStream} readStream */ /** * Writes the given buffer to the key * @param {String} key - The key to write the data to * @param {Buffer} buffer - The raw buffer to write to the key * @param {Sbucket~writeFileCallback} */ Btable.prototype.writeFile = function(key, buffer, callback) { this._getSbucketForKey(key, function(err, sBucket) { if (err) { return callback(err); } sBucket.writeFile(key, buffer, callback); }); }; /** * Creates a writable stream to the given key * @param {String} key - The key to write the data to * @param {Btable~createWriteStreamCallback} */ Btable.prototype.createWriteStream = function(key, callback) { this._getSbucketForKey(key, function(err, sBucket) { if (err) { return callback(err); } callback(null, sBucket.createWriteStream(key)); }); }; /** * @callback Btable~createWriteStreamCallback * @param {Error} [error] * @param {WritableStream} writeStream */ module.exports = Btable; × Search results Close "},"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" KFS Modules kfskfs/constantskfs/utils Classes BtableReadableFileStreamSbucketWritableFileStream Events ReadableFileStream#event:dataReadableFileStream#event:endReadableFileStream#event:errorReadableFileStream#event:readableSbucket#event:closeSbucket#event:idleSbucket#event:openWritableFileStream#event:errorWritableFileStream#event:finish Tutorials Command Line InterfaceProgrammatic UsagePerformance Testing the Changes Source: index.js /** * @module kfs */ 'use strict'; module.exports = require('./lib/b-table'); /** {@link module:kfs/constants} */ module.exports.constants = require('./lib/constants'); /** {@link module:kfs/utils} */ module.exports.utils = require('./lib/utils'); × Search results Close "},"lib_constants.js.html":{"id":"lib_constants.js.html","title":"Source: lib/constants.js","body":" KFS Modules kfskfs/constantskfs/utils Classes BtableReadableFileStreamSbucketWritableFileStream Events ReadableFileStream#event:dataReadableFileStream#event:endReadableFileStream#event:errorReadableFileStream#event:readableSbucket#event:closeSbucket#event:idleSbucket#event:openWritableFileStream#event:errorWritableFileStream#event:finish Tutorials Command Line InterfaceProgrammatic UsagePerformance Testing the Changes Source: lib/constants.js /** * @module kfs/constants */ 'use strict'; module.exports = { /** @constant {Number} R - Number of bits in Reference ID */ R: 160, /** @constant {Number} C - Number of bytes in a file chunk */ C: 65536, /** @constant {Number} S - Number of bytes in a {@link Sbucket} */ S: 32 * (1024 * 1024 * 1024), /** @constant {Number} B - Number of columns in a {@link Btable} */ B: 256, /** @constant {String} HASH - OpenSSL id for key hashing algorithm */ HASH: 'sha1' }; × Search results Close "},"lib_utils.js.html":{"id":"lib_utils.js.html","title":"Source: lib/utils.js","body":" KFS Modules kfskfs/constantskfs/utils Classes BtableReadableFileStreamSbucketWritableFileStream Events ReadableFileStream#event:dataReadableFileStream#event:endReadableFileStream#event:errorReadableFileStream#event:readableSbucket#event:closeSbucket#event:idleSbucket#event:openWritableFileStream#event:errorWritableFileStream#event:finish Tutorials Command Line InterfaceProgrammatic UsagePerformance Testing the Changes Source: lib/utils.js /** * @module kfs/utils */ 'use strict'; var assert = require('assert'); var constants = require('./constants'); var fs = require('fs'); var crypto = require('crypto'); var path = require('path'); /** * A stubbed noop function */ module.exports.noop = function() {}; /** * Tests if the string is a valid key * @param {String} key - The file key * @returns {Boolean} */ module.exports.isValidKey = function(key) { var keyBuffer; try { keyBuffer = Buffer(key, 'hex'); } catch (err) { return false; } return keyBuffer.length === (constants.R / 8); }; /** * Hashes the given key * @param {String} key - The file key * @returns {String} */ module.exports.hashKey = function(key) { if (module.exports.isValidKey(key)) { return key; } return crypto.createHash(constants.HASH).update(key).digest('hex'); }; /** * Coerces input into a valid file key or bucket index * @param {String} keyOrIndex - The bucket index or a file key * @returns {String|Number} */ module.exports.coerceKeyOrIndex = function(keyOrIndex) { var key = keyOrIndex; if (!module.exports.isValidKey(keyOrIndex)) { key = parseInt(keyOrIndex); if (Number.isNaN(key)) { key = module.exports.hashKey(keyOrIndex); } } return key; }; /** * Get the key name for a data hash + index * @param {String} key - Hash of the data * @param {Number} index - The index of the file chunk * @returns {String} */ module.exports.createItemKeyFromIndex = function(key, index) { assert(typeof index === 'number', 'Invalid index supplied'); var fileKey = module.exports.hashKey(key); var indexLength = Math.floor(constants.S / constants.C).toString().length; var indexString = index.toString(); var itemIndex = ''; assert(Buffer(fileKey, 'hex').length * 8 === constants.R, 'Invalid key'); assert(indexString.length &lt;= indexLength, 'Index is out of bounds'); for (var i = 0; i &lt; indexLength - indexString.length; i++) { itemIndex += '0'; } itemIndex += indexString; return [fileKey, ' ', itemIndex].join(''); }; /** * Get the file name of an s bucket based on it's index * @param {Number} sBucketIndex - The index fo the bucket in the B-table * @returns {String} */ module.exports.createSbucketNameFromIndex = function(sBucketIndex) { assert(typeof sBucketIndex === 'number', 'Invalid index supplied'); var indexLength = constants.B.toString().length; var indexString = sBucketIndex.toString(); var leadingZeroes = ''; for (var i = 0; i &lt; indexLength - indexString.length; i++) { leadingZeroes += '0'; } return leadingZeroes + indexString + '.s'; }; /** * Creates a random reference ID * @param {String} [rid] - An existing hex reference ID * @returns {String} */ module.exports.createReferenceId = function(rid) { if (!rid) { rid = crypto.randomBytes(constants.R / 8).toString('hex'); } assert(rid.length === 40, 'Invalid reference ID length'); return Buffer(rid, 'hex'); }; /** * Check if the given path exists * @param {String} filePath * @returns {Boolean} */ module.exports.fileDoesExist = function(filePath) { try { fs.statSync(filePath); } catch (err) { return false; } return true; }; /** * Takes a number of bytes and outputs a human readable size * @param {Number} bytes - The number of bytes to make readable * @returns {String} */ module.exports.toHumanReadableSize = function(bytes) { var thresh = 1024; if (Math.abs(bytes) &lt; thresh) { return bytes + ' B'; } var units = ['KiB','MiB','GiB','TiB','PiB','EiB','ZiB','YiB']; var u = -1; do { bytes /= thresh; ++u; } while (Math.abs(bytes) &gt;= thresh &amp;&amp; u &lt; units.length - 1); return bytes.toFixed(1) + ' ' + units[u]; }; /** * Ensures that the given path has a kfs extension * @param {String} tablePath - The path name to a kfs instance * @returns {String} */ module.exports.coerceTablePath = function(tablePath) { if (path.extname(tablePath) !== '.kfs') { return tablePath + '.kfs'; } return tablePath; }; /** * Determines if the passed error object is a NotFound error * @param {Error} error * @returns {Boolean} */ module.exports.isNotFoundError = function(error) { return error &amp;&amp; error.message.indexOf('NotFound:') !== -1; }; × Search results Close "},"lib_read-stream.js.html":{"id":"lib_read-stream.js.html","title":"Source: lib/read-stream.js","body":" KFS Modules kfskfs/constantskfs/utils Classes BtableReadableFileStreamSbucketWritableFileStream Events ReadableFileStream#event:dataReadableFileStream#event:endReadableFileStream#event:errorReadableFileStream#event:readableSbucket#event:closeSbucket#event:idleSbucket#event:openWritableFileStream#event:errorWritableFileStream#event:finish Tutorials Command Line InterfaceProgrammatic UsagePerformance Testing the Changes Source: lib/read-stream.js 'use strict'; var inherits = require('util').inherits; var ReadableStream = require('readable-stream').Readable; var utils = require('./utils'); /** * Creates a readable stream of a file from a {@link Sbucket} * @constructor * @param {Object} options * @param {Sbucket} options.sBucket * @param {String} options.fileKey */ function ReadableFileStream(options) { if (!(this instanceof ReadableFileStream)) { return new ReadableFileStream(options); } this._sBucket = options.sBucket; this._fileKey = options.fileKey; this._index = 0; ReadableStream.call(this); } /** * Triggered when data is available to read * @event ReadableFileStream#readable */ /** * Triggered when a data is pushed through the stream * @event ReadableFileStream#data * @param {Buffer} bytes */ /** * Triggered when no more data is available * @event ReadableFileStream#end */ /** * Triggered if an error occurs * @event ReadableFileStream#error * @param {Error} error */ inherits(ReadableFileStream, ReadableStream); /** * @private */ ReadableFileStream.prototype._read = function() { var self = this; this._sBucket._db.get( utils.createItemKeyFromIndex(this._fileKey, this._index), function(err, result) { if (err) { if (utils.isNotFoundError(err)) { return self.push(null); } else { return self.emit('error', err); } } self._index++; self.push(Buffer(result, 'binary')); } ); }; /** * Destroys and aborts any reads for this stream * @param {Sbucket~unlinkCallback} */ ReadableFileStream.prototype.destroy = function(callback) { this._sBucket.unlink(this._fileKey, callback); }; module.exports = ReadableFileStream; × Search results Close "},"lib_s-bucket.js.html":{"id":"lib_s-bucket.js.html","title":"Source: lib/s-bucket.js","body":" KFS Modules kfskfs/constantskfs/utils Classes BtableReadableFileStreamSbucketWritableFileStream Events ReadableFileStream#event:dataReadableFileStream#event:endReadableFileStream#event:errorReadableFileStream#event:readableSbucket#event:closeSbucket#event:idleSbucket#event:openWritableFileStream#event:errorWritableFileStream#event:finish Tutorials Command Line InterfaceProgrammatic UsagePerformance Testing the Changes Source: lib/s-bucket.js 'use strict'; var merge = require('merge'); var leveldown = require('leveldown'); var inherits = require('util').inherits; var events = require('events'); var constants = require('./constants'); var utils = require('./utils'); var WritableFileStream = require('./write-stream'); var ReadableFileStream = require('./read-stream'); var async = require('async'); /** * Capped LevelDB database within a {@link Btable} * @constructor * @param {String} dbPath - The path to database on disk * @param {Object} [options] - Options to pass through to leveldown#open * @param {Number} [options.maxOpenFiles=1000] * @param {Boolean} [options.compression=true] * @param {Number} [options.cacheSize=8388608] * @param {Boolean} [options.createIfMissing=true] * @param {Boolean} [options.errorIfExists=false] * @param {Number} [options.writeBufferSize=4194304] * @param {Number} [options.blockSize=4096] * @param {Number} [options.blockRestartInterval=16] */ function Sbucket(dbPath, options) { if (!(this instanceof Sbucket)) { return new Sbucket(dbPath, options); } events.EventEmitter.call(this); this._dbPath = dbPath; this._options = merge(Object.create(Sbucket.DEFAULTS), options); this._db = leveldown(dbPath); this._pendingOperations = 0; this._maxSize = this._options.maxSize; this.readyState = Sbucket.CLOSED; } inherits(Sbucket, events.EventEmitter); /** * Triggered when the underlying database opens * @event Sbucket#open */ /** * Triggered when the underlying database closes * @event Sbucket#close */ /** * Triggered when there are no more pending operations * @event Sbucket#idle */ Sbucket.CLOSED = 4; Sbucket.CLOSING = 3; Sbucket.OPENED = 2; Sbucket.OPENING = 1; Sbucket.SIZE_START_KEY = '0'; Sbucket.SIZE_END_KEY = 'z'; Sbucket.DEFAULTS = { maxOpenFiles: 1000, compression: true, cacheSize: 8 * (1024 * 1024), createIfMissing: true, errorIfExists: false, writeBufferSize: 4 * (1024 * 1024), blockSize: 4096, blockRestartInterval: 16, maxSize: constants.S }; /** * Opens the underlying database * @fires Sbucket#open * @param {Sbucket~openCallback} */ Sbucket.prototype.open = function(callback) { var self = this; callback = callback || utils.noop; function _open() { self.readyState = Sbucket.OPENING; self._db.open(self._options, function(err) { if (err) { return self.emit('error', err); } self.readyState = Sbucket.OPENED; self.emit('open'); }); } function _onError(err) { self.removeListener('open', _onOpen); callback(err); } function _onOpen() { self.removeListener('error', _onError); callback(null); } this.once('open', _onOpen).once('error', _onError); if (this.readyState === Sbucket.OPENED) { return self.emit('open'); } if (this.readyState === Sbucket.OPENING) { return; } if (this.readyState === Sbucket.CLOSING) { return self.once('close', _open); } _open(); }; /** * @callback Sbucket~openCallback * @param {Error} [error] */ /** * Closes the underlying database * @fires Sbucket#close * @param {Sbucket~closeCallback} */ Sbucket.prototype.close = function(callback) { var self = this; callback = callback || utils.noop; function _close() { self.readyState = Sbucket.CLOSING; self._db.close(function(err) { if (err) { return self.emit('error', err); } self.readyState = Sbucket.CLOSED; self.emit('close'); }); } function _onError(err) { self.removeListener('close', _onClose); callback(err); } function _onClose() { self.removeListener('error', _onError); callback(null); } this.once('close', _onClose).once('error', _onError); if (this.readyState === Sbucket.CLOSED) { return self.emit('close'); } if (this.readyState === Sbucket.CLOSING) { return; } if (this.readyState === Sbucket.OPENING) { return this.once('open', _close); } _close(); }; /** * @callback Sbucket~closeCallback * @param {Error} [error] */ /** * Determines if the file is already stored in the db * @param {String} key - The key for the file stored * @param {Sbucket~existsCallback} */ Sbucket.prototype.exists = function(key, callback) { var self = this; this._incPendingOps(); this._db.get(utils.createItemKeyFromIndex(key, 0), function(err) { self._decPendingOps(); callback(null, !err); }); }; /** * @callback Sbucket~existsCallback * @param {Error} [error] * @param {Boolean} fileDoesExist */ /** * Deletes the file chunks from the database * @param {String} key - The key for the file stored * @param {Sbucket~unlinkCallback} */ Sbucket.prototype.unlink = function(key, callback) { var self = this; var index = 0; function _del(index, callback) { var itemKey = utils.createItemKeyFromIndex(key, index); self._db.get(itemKey, function(err) { index++; if (!err) { self._db.del(itemKey, function() { _del(index, callback); }); } else if (utils.isNotFoundError(err)) { self._decPendingOps(); callback(null); } else { self._decPendingOps(); callback(err); } }); } this._incPendingOps(); _del(index, callback); }; /** * @callback Sbucket~unlinkCallback * @param {Error} [error] */ /** * Reads the file at the given key into a buffer * @param {String} key - The key for the file to read * @param {Sbucket~readFileCallback} */ Sbucket.prototype.readFile = function(key, callback) { var self = this; var fileBuffer = new Buffer([], 'binary'); var readStream = this.createReadStream(key); readStream.on('data', function(data) { fileBuffer = Buffer.concat([fileBuffer, data]); }); readStream.on('end', function() { self._decPendingOps(); callback(null, fileBuffer); }); readStream.on('error', function(err) { self._decPendingOps(); readStream.removeAllListeners(); callback(err); }); this._incPendingOps(); }; /** * @callback Sbucket~readFileCallback * @param {Error} [error] * @param {Buffer} fileBuffer */ /** * Writes the buffer to the given key * @param {String} key - The key for the file to write * @param {Buffer} buffer - The data to write to the given key * @param {Sbucket~writeFileCallback} */ Sbucket.prototype.writeFile = function(key, buffer, callback) { var self = this; var writeStream = this.createWriteStream(key); var whichSlice = 0; function _writeFileSlice() { var startIndex = whichSlice * constants.C; var endIndex = startIndex + constants.C; var bufferSlice = buffer.slice(startIndex, endIndex); if (bufferSlice.length === 0) { return writeStream.end(); } whichSlice++; writeStream.write(bufferSlice); _writeFileSlice(); } writeStream.on('finish', function() { self._decPendingOps(); callback(null); }); writeStream.on('error', function(err) { self._decPendingOps(); writeStream.removeAllListeners(); callback(err); }); this._incPendingOps(); this.unlink(key, _writeFileSlice); }; /** * @callback Sbucket~writeFileCallback * @param {Error} [error] */ /** * Returns a readable stream of the file at the given key * @param {String} key - The key for the file to read * @returns {ReadableFileStream} */ Sbucket.prototype.createReadStream = function(key) { var rs = new ReadableFileStream({ sBucket: this, fileKey: key }); this._incPendingOps(); rs.on('end', this._decPendingOps.bind(this)); return rs; }; /** * Returns a writable stream for a file at the given key * @param {String} key - The key for the file to read * @returns {WritableFileStream} */ Sbucket.prototype.createWriteStream = function(key) { var ws = new WritableFileStream({ sBucket: this, fileKey: key }); this._incPendingOps(); ws.on('finish', this._decPendingOps.bind(this)); return ws; }; /** * Get stats for this bucket * @param {Sbucket~statCallback} */ Sbucket.prototype.stat = function(callback) { var self = this; this._incPendingOps(); this._db.approximateSize( Sbucket.SIZE_START_KEY, Sbucket.SIZE_END_KEY, function(err, size) { self._decPendingOps(); if (err) { return callback(err); } callback(null, { size: size, free: self._maxSize - size }); } ); }; /** * @callback Sbucket~statCallback * @param {Error} [error] * @param {Object} bucketStats * @param {Number} bucketStats.size - The used space in bytes * @param {Number} bucketStats.free - The free space left in bytes */ /** * Get a list of file keys in the bucket and their approximate size * @param {Sbucket~listCallback} */ Sbucket.prototype.list = function(callback) { var self = this; var iterator = this._db.iterator({ gte: Sbucket.SIZE_START_KEY, lte: Sbucket.SIZE_END_KEY, values: false, keyAsBuffer: false }); var keys = {}; var currentResult = null; function _test() { return currentResult === null; } function _accumulateKey(next) { iterator.next(function(err, key) { if (err) { return next(err); } if (!key) { currentResult = null; return next(); } currentResult = key.split(' ')[0]; keys[currentResult] = keys[currentResult] ? keys[currentResult] + constants.C : constants.C; next(); }); } this._incPendingOps(); async.doUntil(_accumulateKey, _test, function(err) { self._decPendingOps(); if (err) { return callback(err); } var results = []; for (var key in keys) { results.push({ baseKey: key, approximateSize: keys[key] }); } callback(null, results); }); }; /** * @callback Sbucket~listCallback * @param {Error} [error] * @param {Object[]} results * @param {String} results.baseKey * @param {Number} results.approximateSize */ /** * Increments the pending operations counter * @private */ Sbucket.prototype._incPendingOps = function() { this._pendingOperations++; }; /** * Decrements the pending operations counter * @private * @fires Sbucket#idle */ Sbucket.prototype._decPendingOps = function() { var self = this; function _checkIdleState() { if (self._pendingOperations === 0) { self.emit('idle'); } } this._pendingOperations--; setImmediate(_checkIdleState); }; module.exports = Sbucket; × Search results Close "},"lib_write-stream.js.html":{"id":"lib_write-stream.js.html","title":"Source: lib/write-stream.js","body":" KFS Modules kfskfs/constantskfs/utils Classes BtableReadableFileStreamSbucketWritableFileStream Events ReadableFileStream#event:dataReadableFileStream#event:endReadableFileStream#event:errorReadableFileStream#event:readableSbucket#event:closeSbucket#event:idleSbucket#event:openWritableFileStream#event:errorWritableFileStream#event:finish Tutorials Command Line InterfaceProgrammatic UsagePerformance Testing the Changes Source: lib/write-stream.js 'use strict'; var inherits = require('util').inherits; var WritableStream = require('readable-stream').Writable; var utils = require('./utils'); /** * Creates a writable stream for storing a file in an {@link Sbucket} * @constructor * @param {Object} options * @param {Sbucket} options.sBucket - The S-bucket this stream will write to * @param {String} options.fileKey - The key for the file to write to */ function WritableFileStream(options) { if (!(this instanceof WritableFileStream)) { return new WritableFileStream(options); } this._sBucket = options.sBucket; this._fileKey = options.fileKey; this._index = 0; WritableStream.call(this); } /** * Triggered if an error occurs * @event WritableFileStream#error * @param {Error} error */ /** * Triggered when data is finished writing * @event WritableFileStream#finish */ inherits(WritableFileStream, WritableStream); /** * @private */ WritableStream.prototype._write = function(bytes, encoding, callback) { var self = this; this._sBucket._db.put( utils.createItemKeyFromIndex(this._fileKey, this._index), bytes, function(err) { if (err) { return callback(err); } self._index++; callback(); } ); }; /** * Destroys and aborts any writes for this stream * @param {Sbucket~unlinkCallback} */ WritableFileStream.prototype.destroy = function(callback) { this._sBucket.unlink(this._fileKey, callback); }; module.exports = WritableFileStream; × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" KFS Modules kfskfs/constantskfs/utils Classes BtableReadableFileStreamSbucketWritableFileStream Events ReadableFileStream#event:dataReadableFileStream#event:endReadableFileStream#event:errorReadableFileStream#event:readableSbucket#event:closeSbucket#event:idleSbucket#event:openWritableFileStream#event:errorWritableFileStream#event:finish Tutorials Command Line InterfaceProgrammatic UsagePerformance Testing the Changes Modules Classes Btable ReadableFileStream Sbucket WritableFileStream Events data Triggered when a data is pushed through the stream Parameters: Name Type Description bytes Buffer Source: lib/read-stream.js end Triggered when no more data is available Source: lib/read-stream.js error Triggered if an error occurs Parameters: Name Type Description error Error Source: lib/read-stream.js readable Triggered when data is available to read Source: lib/read-stream.js close Triggered when the underlying database closes Source: lib/s-bucket.js idle Triggered when there are no more pending operations Source: lib/s-bucket.js open Triggered when the underlying database opens Source: lib/s-bucket.js error Triggered if an error occurs Parameters: Name Type Description error Error Source: lib/write-stream.js finish Triggered when data is finished writing Source: lib/write-stream.js × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" KFS Modules kfskfs/constantskfs/utils Classes BtableReadableFileStreamSbucketWritableFileStream Events ReadableFileStream#event:dataReadableFileStream#event:endReadableFileStream#event:errorReadableFileStream#event:readableSbucket#event:closeSbucket#event:idleSbucket#event:openWritableFileStream#event:errorWritableFileStream#event:finish Tutorials Command Line InterfaceProgrammatic UsagePerformance Testing the Changes Classes Classes Btable ReadableFileStream Sbucket WritableFileStream Events data Triggered when a data is pushed through the stream Parameters: Name Type Description bytes Buffer Source: lib/read-stream.js end Triggered when no more data is available Source: lib/read-stream.js error Triggered if an error occurs Parameters: Name Type Description error Error Source: lib/read-stream.js readable Triggered when data is available to read Source: lib/read-stream.js close Triggered when the underlying database closes Source: lib/s-bucket.js idle Triggered when there are no more pending operations Source: lib/s-bucket.js open Triggered when the underlying database opens Source: lib/s-bucket.js error Triggered if an error occurs Parameters: Name Type Description error Error Source: lib/write-stream.js finish Triggered when data is finished writing Source: lib/write-stream.js × Search results Close "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" KFS Modules kfskfs/constantskfs/utils Classes BtableReadableFileStreamSbucketWritableFileStream Events ReadableFileStream#event:dataReadableFileStream#event:endReadableFileStream#event:errorReadableFileStream#event:readableSbucket#event:closeSbucket#event:idleSbucket#event:openWritableFileStream#event:errorWritableFileStream#event:finish Tutorials Command Line InterfaceProgrammatic UsagePerformance Testing the Changes Tutorials Classes Btable ReadableFileStream Sbucket WritableFileStream Events data Triggered when a data is pushed through the stream Parameters: Name Type Description bytes Buffer Source: lib/read-stream.js end Triggered when no more data is available Source: lib/read-stream.js error Triggered if an error occurs Parameters: Name Type Description error Error Source: lib/read-stream.js readable Triggered when data is available to read Source: lib/read-stream.js close Triggered when the underlying database closes Source: lib/s-bucket.js idle Triggered when there are no more pending operations Source: lib/s-bucket.js open Triggered when the underlying database opens Source: lib/s-bucket.js error Triggered if an error occurs Parameters: Name Type Description error Error Source: lib/write-stream.js finish Triggered when data is finished writing Source: lib/write-stream.js × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" KFS Modules kfskfs/constantskfs/utils Classes BtableReadableFileStreamSbucketWritableFileStream Events ReadableFileStream#event:dataReadableFileStream#event:endReadableFileStream#event:errorReadableFileStream#event:readableSbucket#event:closeSbucket#event:idleSbucket#event:openWritableFileStream#event:errorWritableFileStream#event:finish Tutorials Command Line InterfaceProgrammatic UsagePerformance Testing the Changes KFS is a local file storage system inspired by Kademlia. The KFS system describes a method for managing the storage layer of nodes on the Storj Network by creating a sharded local database where content-addressable data is placed in a shard using the same routing metric and algorithm used by the Kademlia distributed hash table. Quick StartInstall the kfs package using Node Package Manager. npm install kfs --saveThis will install kfs as a dependency of your own project. See the documentation for usage details. MotivationThe Storj network consists of a number of distributed peers who provide storage capacity for lease to others. In its current implementation, these nodes store encrypted shards and their associated metadata in a LevelDB. LevelDB provides a number of features that make it desirable for this use case; this includes its lexicographically sorted keys providing fast lookups for content-addressable values, fast and efficient compression, and perhaps most notably its portability which allows the Storj software to run on a wide range of hardware including dated or underpowered computers. However, due to the nature of LevelDB's design and its implementation in the Storj software, its performance suffers after the size of the database exceeds approximately 100GiB. This impact is larger on lower end systems and can also vary based on the type of disk in use. These performance issues seem to arise from LevelDB's compaction mechanism (which is an otherwise desirable feature). In addition to the cost of compaction, LevelDB blocks reads and writes during this process, which causes storage nodes to become effectively offline until the process completes. These properties indicate that if the size of a single database can be given an upper bound, then the cost of compaction can be significantly reduced to an acceptable level. Futhermore, in using a single database, if one level becomes corrupted, deleted, or otherwise inaccessible, the entire database may become unusable and unrecoverable. For these reasons, the KFS system seeks to create a series of size-capped databases where data is stored in a given &quot;shard&quot; based on a deterministic metric to ensure a sufficiently random and even spread to bound the cost of compaction, to reduce the impact of corruption, and to completely eliminate the need to maintain an index or state machine to efficiently lookup stored data. MechanicsS-Buckets and RoutingKFS requires that there be a reference identifier, which can be any arbitrary R bit key. This can be randomly generated upon creation of the database or derived from some other application or protocol specific information. In the Storj network, nodes are addressed with a 160 bit node identifier derived from the public portion of an ECDSA key pair. This Reference ID is used to calculate the database shard or S-Bucket to which a given piece of data belongs. Collectively, these S-Buckets form the B-Table. In KFS, there are a total of B S-Buckets, numbered 0-B-1. To determine which bucket a piece of raw binary data belongs in, calculate the distance between the first byte of the hash of the data and the first byte of the reference ID. This is to say that if the distance between those bytes is 137, then the raw binary data should be stored in S-Bucket 137. An S-Bucket has a fixed size, S, in bytes. This means that a KFS database has a maximum size of B * S bytes. Once an S-Bucket is full, no more data can be placed in it. Once a KFS database is full, another should be created using a new Reference ID. Given the default constants, KFS databases are capped at a maximum of 8TiB each. Keying Data by ChunksTo optimize the efficiency of reads and writes in KFS, data is stored in C sized chunks (or less), keyed by the full content's hash, followed by a space and a numerical index. This is performed to ensure that key/value pairs are small and that reading and writing data to and from a S-Bucket is done sequentially and can allow for efficient streaming of data both in and out of the S-bucket. Since LevelDB sorts items lexicographically, keys for data chunks should be strings and consist of: Hexidecimal(Hash) + ' ' + 00000N The number of preceding zeroes in the numerical index should be set such that a S-Bucket that contains only a single file split into C sized chunks can still be read sequentially from the database. Using the default constants would make the highest number index 524288, so the number of leading zeroes should be less than or equal to five. Ad-Hoc S-Bucket InitializationGiven the low cost of creating and opening a LevelDB, it is not necessary to create all B S-Buckets at once. Instead, an S-Bucket can be created the first time data is to be stored inside of it. Additionally, S-Buckets can be opened and closed as needed, eliminating the potential overhead of opening a large number of file descriptors. Operations on a given S-Bucket should be added to a queue which when drained may trigger a close of the S-Bucket's underlying database. Due to the nature of Kademlia's metric for determining distance, buckets will fill approximately evenly. The result of the XOR operation on the pseudo-random first bytes of the reference ID and hash should give any given bucket a relatively even chance of receiving any given file. Below is the frequency distribution plotted with ten million simulated calculations. As expected the distribution is uniform (the red dotted line indicates the theoretical value each bin should have): Even with a uniform distribution, as the node reaches capacity some buckets will fill sooner than others. Offers that would be sorted into these buckets should be declined and relayed to other nodes. Constants Name Description Default B Number of columns in the B-table 256 S Size (in bytes) of an S-Bucket 34359738368 (32GiB) C Size (in bytes) of a file chunk 65536 R Number of bits in the Reference ID 160 Considerations Specific to Storj Storj farmers receive contracts for data shards that are already close to their own Node ID. To improve S-Bucket distribution, it may be desirable to double hash the data or otherwise force a degree of randomness before selecting a S-Bucket for storage. The use of KFS in the Storj network creates an upper limit to how much data can be stored by a given Node ID (or identity). This encourages farmers to operate multiple nodes with different identities which lends itself to better network integration. The use of HD (hierachical deterministic) private keys could allow a single farmer identity to assume multiple Reference IDs, thus eliminating the limit. KFS does not track or store metadata about the contents of a S-Bucket, which in the context of the Storj network would include contracts and other special information related to a piece of data. Applications should handle this via their own means. LicenseKFS - A Local File Storage System Inspired by KademliaCopyright (C) 2016 Storj Labs, Inc This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see [http://www.gnu.org/licenses/]. × Search results Close "},"Btable.html":{"id":"Btable.html","title":"Class: Btable","body":" KFS Modules kfskfs/constantskfs/utils Classes BtableReadableFileStreamSbucketWritableFileStream Events ReadableFileStream#event:dataReadableFileStream#event:endReadableFileStream#event:errorReadableFileStream#event:readableSbucket#event:closeSbucket#event:idleSbucket#event:openWritableFileStream#event:errorWritableFileStream#event:finish Tutorials Command Line InterfaceProgrammatic UsagePerformance Testing the Changes Class: Btable Btable new Btable(tablePath [, options]) A series of Sbuckets composing a sharded table Parameters: Name Type Argument Description tablePath String The path to the directory to store the table options Object &lt;optional&gt; Properties Name Type Argument Description referenceId String &lt;optional&gt; R bit hex reference ID maxTableSize Number &lt;optional&gt; Max bytes to cap the database sBucketOpts Object &lt;optional&gt; Options to pass to Sbucket creation Source: lib/b-table.js Methods createReadStream(key, callback) Creates a readable stream of the data at the given key Parameters: Name Type Description key String The key for the data read callback Btable~createReadStreamCallback Source: lib/b-table.js createWriteStream(key, callback) Creates a writable stream to the given key Parameters: Name Type Description key String The key to write the data to callback Btable~createWriteStreamCallback Source: lib/b-table.js exists(key, callback) Check if a file exists at the supplied key Parameters: Name Type Description key String The key to check for existence callback Sbucket~existsCallback Source: lib/b-table.js list(keyOrIndex, callback) Lists the file keys in the given bucket Parameters: Name Type Description keyOrIndex Number | String The bucket index of a file key callback Sbucket~listCallback Source: lib/b-table.js readFile(key, callback) Reads the data at the supplied key into a buffer Parameters: Name Type Description key String The key for the data to read callback Sbucket~readFileCallback Source: lib/b-table.js stat( [keyOrIndex], callback) Lists the created Sbuckets and their sizes Parameters: Name Type Argument Description keyOrIndex String | Number &lt;optional&gt; Optional bucket index or file key callback Btable~statCallback Source: lib/b-table.js unlink(key, callback) Unlinks the data for the given key Parameters: Name Type Description key String The key to unlink data from callback Sbucket~unlinkCallback Source: lib/b-table.js writeFile(key, buffer, callback) Writes the given buffer to the key Parameters: Name Type Description key String The key to write the data to buffer Buffer The raw buffer to write to the key callback Sbucket~writeFileCallback Source: lib/b-table.js Type Definitions createReadStreamCallback( [error], readStream) Parameters: Name Type Argument Description error Error &lt;optional&gt; readStream ReadableStream Source: lib/b-table.js createWriteStreamCallback( [error], writeStream) Parameters: Name Type Argument Description error Error &lt;optional&gt; writeStream WritableStream Source: lib/b-table.js statCallback( [error], sBuckets) Parameters: Name Type Argument Description error Error &lt;optional&gt; sBuckets Array.&lt;Object&gt; sBuckets[].sBucketIndex String The index of the S-bucket sBuckets[].sBucketStats Object Properties Name Type Description used Number Space used in the bucket free Number Space free in the bucket Source: lib/b-table.js × Search results Close "},"module-kfs.html":{"id":"module-kfs.html","title":"Module: kfs","body":" KFS Modules kfskfs/constantskfs/utils Classes BtableReadableFileStreamSbucketWritableFileStream Events ReadableFileStream#event:dataReadableFileStream#event:endReadableFileStream#event:errorReadableFileStream#event:readableSbucket#event:closeSbucket#event:idleSbucket#event:openWritableFileStream#event:errorWritableFileStream#event:finish Tutorials Command Line InterfaceProgrammatic UsagePerformance Testing the Changes Module: kfs Source: index.js Members &lt;static&gt; constants module:kfs/constants Source: index.js &lt;static&gt; utils module:kfs/utils Source: index.js × Search results Close "},"module-kfs_constants.html":{"id":"module-kfs_constants.html","title":"Module: kfs/constants","body":" KFS Modules kfskfs/constantskfs/utils Classes BtableReadableFileStreamSbucketWritableFileStream Events ReadableFileStream#event:dataReadableFileStream#event:endReadableFileStream#event:errorReadableFileStream#event:readableSbucket#event:closeSbucket#event:idleSbucket#event:openWritableFileStream#event:errorWritableFileStream#event:finish Tutorials Command Line InterfaceProgrammatic UsagePerformance Testing the Changes Module: kfs/constants Source: lib/constants.js Members &lt;inner, constant&gt; B :Number Number of columns in a Btable Type: Number Source: lib/constants.js &lt;inner, constant&gt; C :Number Number of bytes in a file chunk Type: Number Source: lib/constants.js &lt;inner, constant&gt; HASH :String OpenSSL id for key hashing algorithm Type: String Source: lib/constants.js &lt;inner, constant&gt; R :Number Number of bits in Reference ID Type: Number Source: lib/constants.js &lt;inner, constant&gt; S :Number Number of bytes in a Sbucket Type: Number Source: lib/constants.js × Search results Close "},"module-kfs_utils.html":{"id":"module-kfs_utils.html","title":"Module: kfs/utils","body":" KFS Modules kfskfs/constantskfs/utils Classes BtableReadableFileStreamSbucketWritableFileStream Events ReadableFileStream#event:dataReadableFileStream#event:endReadableFileStream#event:errorReadableFileStream#event:readableSbucket#event:closeSbucket#event:idleSbucket#event:openWritableFileStream#event:errorWritableFileStream#event:finish Tutorials Command Line InterfaceProgrammatic UsagePerformance Testing the Changes Module: kfs/utils Source: lib/utils.js Methods &lt;static&gt; coerceKeyOrIndex(keyOrIndex) Coerces input into a valid file key or bucket index Parameters: Name Type Description keyOrIndex String The bucket index or a file key Source: lib/utils.js Returns: Type String | Number &lt;static&gt; coerceTablePath(tablePath) Ensures that the given path has a kfs extension Parameters: Name Type Description tablePath String The path name to a kfs instance Source: lib/utils.js Returns: Type String &lt;static&gt; createItemKeyFromIndex(key, index) Get the key name for a data hash + index Parameters: Name Type Description key String Hash of the data index Number The index of the file chunk Source: lib/utils.js Returns: Type String &lt;static&gt; createReferenceId( [rid]) Creates a random reference ID Parameters: Name Type Argument Description rid String &lt;optional&gt; An existing hex reference ID Source: lib/utils.js Returns: Type String &lt;static&gt; createSbucketNameFromIndex(sBucketIndex) Get the file name of an s bucket based on it's index Parameters: Name Type Description sBucketIndex Number The index fo the bucket in the B-table Source: lib/utils.js Returns: Type String &lt;static&gt; fileDoesExist(filePath) Check if the given path exists Parameters: Name Type Description filePath String Source: lib/utils.js Returns: Type Boolean &lt;static&gt; hashKey(key) Hashes the given key Parameters: Name Type Description key String The file key Source: lib/utils.js Returns: Type String &lt;static&gt; isNotFoundError(error) Determines if the passed error object is a NotFound error Parameters: Name Type Description error Error Source: lib/utils.js Returns: Type Boolean &lt;static&gt; isValidKey(key) Tests if the string is a valid key Parameters: Name Type Description key String The file key Source: lib/utils.js Returns: Type Boolean &lt;static&gt; noop() A stubbed noop function Source: lib/utils.js &lt;static&gt; toHumanReadableSize(bytes) Takes a number of bytes and outputs a human readable size Parameters: Name Type Description bytes Number The number of bytes to make readable Source: lib/utils.js Returns: Type String × Search results Close "},"ReadableFileStream.html":{"id":"ReadableFileStream.html","title":"Class: ReadableFileStream","body":" KFS Modules kfskfs/constantskfs/utils Classes BtableReadableFileStreamSbucketWritableFileStream Events ReadableFileStream#event:dataReadableFileStream#event:endReadableFileStream#event:errorReadableFileStream#event:readableSbucket#event:closeSbucket#event:idleSbucket#event:openWritableFileStream#event:errorWritableFileStream#event:finish Tutorials Command Line InterfaceProgrammatic UsagePerformance Testing the Changes Class: ReadableFileStream ReadableFileStream new ReadableFileStream(options) Creates a readable stream of a file from a Sbucket Parameters: Name Type Description options Object Properties Name Type Description sBucket Sbucket fileKey String Source: lib/read-stream.js Methods destroy(callback) Destroys and aborts any reads for this stream Parameters: Name Type Description callback Sbucket~unlinkCallback Source: lib/read-stream.js Events data Triggered when a data is pushed through the stream Parameters: Name Type Description bytes Buffer Source: lib/read-stream.js end Triggered when no more data is available Source: lib/read-stream.js error Triggered if an error occurs Parameters: Name Type Description error Error Source: lib/read-stream.js readable Triggered when data is available to read Source: lib/read-stream.js × Search results Close "},"Sbucket.html":{"id":"Sbucket.html","title":"Class: Sbucket","body":" KFS Modules kfskfs/constantskfs/utils Classes BtableReadableFileStreamSbucketWritableFileStream Events ReadableFileStream#event:dataReadableFileStream#event:endReadableFileStream#event:errorReadableFileStream#event:readableSbucket#event:closeSbucket#event:idleSbucket#event:openWritableFileStream#event:errorWritableFileStream#event:finish Tutorials Command Line InterfaceProgrammatic UsagePerformance Testing the Changes Class: Sbucket Sbucket new Sbucket(dbPath [, options]) Capped LevelDB database within a Btable Parameters: Name Type Argument Description dbPath String The path to database on disk options Object &lt;optional&gt; Options to pass through to leveldown#open Properties Name Type Argument Default Description maxOpenFiles Number &lt;optional&gt; 1000 compression Boolean &lt;optional&gt; true cacheSize Number &lt;optional&gt; 8388608 createIfMissing Boolean &lt;optional&gt; true errorIfExists Boolean &lt;optional&gt; false writeBufferSize Number &lt;optional&gt; 4194304 blockSize Number &lt;optional&gt; 4096 blockRestartInterval Number &lt;optional&gt; 16 Source: lib/s-bucket.js Methods close(callback) Closes the underlying database Parameters: Name Type Description callback Sbucket~closeCallback Source: lib/s-bucket.js Fires: Sbucket#event:close createReadStream(key) Returns a readable stream of the file at the given key Parameters: Name Type Description key String The key for the file to read Source: lib/s-bucket.js Returns: Type ReadableFileStream createWriteStream(key) Returns a writable stream for a file at the given key Parameters: Name Type Description key String The key for the file to read Source: lib/s-bucket.js Returns: Type WritableFileStream exists(key, callback) Determines if the file is already stored in the db Parameters: Name Type Description key String The key for the file stored callback Sbucket~existsCallback Source: lib/s-bucket.js list(callback) Get a list of file keys in the bucket and their approximate size Parameters: Name Type Description callback Sbucket~listCallback Source: lib/s-bucket.js open(callback) Opens the underlying database Parameters: Name Type Description callback Sbucket~openCallback Source: lib/s-bucket.js Fires: Sbucket#event:open readFile(key, callback) Reads the file at the given key into a buffer Parameters: Name Type Description key String The key for the file to read callback Sbucket~readFileCallback Source: lib/s-bucket.js stat(callback) Get stats for this bucket Parameters: Name Type Description callback Sbucket~statCallback Source: lib/s-bucket.js unlink(key, callback) Deletes the file chunks from the database Parameters: Name Type Description key String The key for the file stored callback Sbucket~unlinkCallback Source: lib/s-bucket.js writeFile(key, buffer, callback) Writes the buffer to the given key Parameters: Name Type Description key String The key for the file to write buffer Buffer The data to write to the given key callback Sbucket~writeFileCallback Source: lib/s-bucket.js Type Definitions closeCallback( [error]) Parameters: Name Type Argument Description error Error &lt;optional&gt; Source: lib/s-bucket.js existsCallback( [error], fileDoesExist) Parameters: Name Type Argument Description error Error &lt;optional&gt; fileDoesExist Boolean Source: lib/s-bucket.js listCallback( [error], results) Parameters: Name Type Argument Description error Error &lt;optional&gt; results Array.&lt;Object&gt; Properties Name Type Description baseKey String approximateSize Number Source: lib/s-bucket.js openCallback( [error]) Parameters: Name Type Argument Description error Error &lt;optional&gt; Source: lib/s-bucket.js readFileCallback( [error], fileBuffer) Parameters: Name Type Argument Description error Error &lt;optional&gt; fileBuffer Buffer Source: lib/s-bucket.js statCallback( [error], bucketStats) Parameters: Name Type Argument Description error Error &lt;optional&gt; bucketStats Object Properties Name Type Description size Number The used space in bytes free Number The free space left in bytes Source: lib/s-bucket.js unlinkCallback( [error]) Parameters: Name Type Argument Description error Error &lt;optional&gt; Source: lib/s-bucket.js writeFileCallback( [error]) Parameters: Name Type Argument Description error Error &lt;optional&gt; Source: lib/s-bucket.js Events close Triggered when the underlying database closes Source: lib/s-bucket.js idle Triggered when there are no more pending operations Source: lib/s-bucket.js open Triggered when the underlying database opens Source: lib/s-bucket.js × Search results Close "},"WritableFileStream.html":{"id":"WritableFileStream.html","title":"Class: WritableFileStream","body":" KFS Modules kfskfs/constantskfs/utils Classes BtableReadableFileStreamSbucketWritableFileStream Events ReadableFileStream#event:dataReadableFileStream#event:endReadableFileStream#event:errorReadableFileStream#event:readableSbucket#event:closeSbucket#event:idleSbucket#event:openWritableFileStream#event:errorWritableFileStream#event:finish Tutorials Command Line InterfaceProgrammatic UsagePerformance Testing the Changes Class: WritableFileStream WritableFileStream new WritableFileStream(options) Creates a writable stream for storing a file in an Sbucket Parameters: Name Type Description options Object Properties Name Type Description sBucket Sbucket The S-bucket this stream will write to fileKey String The key for the file to write to Source: lib/write-stream.js Methods destroy(callback) Destroys and aborts any writes for this stream Parameters: Name Type Description callback Sbucket~unlinkCallback Source: lib/write-stream.js Events error Triggered if an error occurs Parameters: Name Type Description error Error Source: lib/write-stream.js finish Triggered when data is finished writing Source: lib/write-stream.js × Search results Close "},"tutorial-cli.html":{"id":"tutorial-cli.html","title":"Tutorial: Command Line Interface","body":" KFS Modules kfskfs/constantskfs/utils Classes BtableReadableFileStreamSbucketWritableFileStream Events ReadableFileStream#event:dataReadableFileStream#event:endReadableFileStream#event:errorReadableFileStream#event:readableSbucket#event:closeSbucket#event:idleSbucket#event:openWritableFileStream#event:errorWritableFileStream#event:finish Tutorials Command Line InterfaceProgrammatic UsagePerformance Testing the Changes Command Line Interface KFS comes bundles with a handy command line interface for dealing with your databases. You can access this tool by installing the package globally: npm install -g kfsOnce the installation completes, you can use the kfs command. To see usage information, run: &gt; $ kfs --help Usage: kfs [options] [command] Commands: write &lt;file_key&gt; [file_path] write the file to the database (or read from stdin) read &lt;file_key&gt; [file_path] read the file from the database (or write to stdout) unlink &lt;file_key&gt; unlink (delete) the file from the database stat [options] &lt;file_key&gt; get the available space for a file key * print usage information to the console Options: -h, --help output usage information -V, --version output the version number -d, --db &lt;db_path&gt; path the kfs database to use (default: /home/bookchin/.kfs/default)Writing a File To KFSThere are two ways to write a file to a KFS database: Supplying an optional path to an existing file Reading from STDIN To write a file that exists on the file system already, just supply it's path: kfs write somefilekey /path/to/my/file.binTo have the CLI read from STDIN, just pipe the output of another program to it: cat /path/to/my/file.bin | kfs write somefilekeyIf an error is encountered, the process will terminate and write the error message to STDERR. Reading a File From KFSThere are two ways to read a file from a KFS database: Supplying a path to write the output Writing to STDOUT To read from a KFS and write it to a file, just supply a path: kfs read somefilekey /path/to/write/file.webmTo have the CLI write to STDOUT, just pipe the output to another program: kfs read somefilekey | mplayer -If an error is encountered, the process will terminate and write the error message to STDERR. Unlinking a File From KFSTo unlink (or mark for deletion), simply provide the file key: kfs unlink somefilekeyIf an error is encountered, the process will terminate and write the error message to STDERR. Getting Stats for a KFSYou can see the amount of space available for a given file key: kfs stat somefilekey 246.s 34359738368This writes the S-bucket index and the number of bytes available to STDOUT. You can also view this in a human readable form with the -h option: kfs stat somefilekey -h 246.s 32.0 GiB × Search results Close "},"tutorial-kfs.html":{"id":"tutorial-kfs.html","title":"Tutorial: Programmatic Usage","body":" KFS Modules kfskfs/constantskfs/utils Classes BtableReadableFileStreamSbucketWritableFileStream Events ReadableFileStream#event:dataReadableFileStream#event:endReadableFileStream#event:errorReadableFileStream#event:readableSbucket#event:closeSbucket#event:idleSbucket#event:openWritableFileStream#event:errorWritableFileStream#event:finish Tutorials Command Line InterfaceProgrammatic UsagePerformance Testing the Changes Programmatic Usage This tutorial covers everything you need to know about using KFS within your application. KFS is based on LevelDB, an embedded key-value store, but the interface for interacting with a KFS is focused on the storage and retrieval of files and arbitrary binary streams. Getting StartedTo create and open a new KFS database (or open an existing one), simply require the module and create a Btable object: var kfs = require('kfs'); var myDataStore = kfs('/path/to/database.kfs');That's it, Your data store is ready to use! Check if a File ExistsTo check if a file exists at a given key, use the Btable#exists method: var some160bitKey = 'adc83b19e793491b1c6ea0fd8b46cd9f32e592fc'; myDataStore.exists(some160bitKey, function(err, exists) { console.log('The file ' + (exists ? 'DOES' : 'DOES NOT') + ' exist!'); });Check if a File Can Be StoredTo check the available space for a file at a given key, use the Btable#getSpaceAvailableForKey method: var fileSizeInBytes = 4096; myDataStore.stat(some160bitKey, function(err, result) { if (err) { // handle error } var enoughFreeSpace = result.sBucketStats.free &gt; fileSizeInBytes; console.log('There ' + (enoughFreeSpace ? 'IS': 'IS NOT') + ' enough space!'); });Write a File to the Data StoreTo write a raw buffer to the data store, use the Btable#writeFile method: var myFileBuffer = new Buffer([/* ... */]); myDataStore.writeFile(some160bitKey, myFileBuffer, function(err) { console.log('File ' + (err ? 'WAS NOT' : 'WAS') + ' written!'); });Read a File from the Data StoreTo read a file into memory from the data store, use the Btable#readFile method: myDataStore.readFile(some160bitKey, function(err, fileBuffer) { console.log(err || fileBuffer); });Remove a File from the Data StoreTo remove a file from the data store, use the Btable#unlink method: myDataStore.unlink(some160bitKey, function(err) { console.log('The file ' + (err ? 'WAS NOT' : 'WAS') + ' removed!'); });Use the Streaming InterfacesWhen reading or writing larger files, you may not wish to buffer everything into memory. In these cases, use the Btable#createReadStream and Btable#createWriteStream methods: myDataStore.createReadStream(some160bitKey, function(err, readableStream) { if (err) { // handle error } readableStream.on('data', function(chunk) { console.log('Got chunk:', chunk); }); readableStream.on('end', function() { console.log('All chunks read!'); }); readableStream.on('error', function(err) { console.log('Failed to read file:', err.message); }); });myDataStore.createWriteStream(some160bitKey, function(err, writableStream) { if (err) { // handle error } writableStream.on('finish', function() { console.log('All chunks written!'); }); writableStream.on('error', function(err) { console.log('Failed to write file:', err.message); }); writableStream.write(new Buffer([/* ... */])); writableStream.write(new Buffer([/* ... */])); writableStream.write(new Buffer([/* ... */])); writableStream.end(); }); × Search results Close "},"tutorial-performance-testing.html":{"id":"tutorial-performance-testing.html","title":"Tutorial: Performance Testing the Changes","body":" KFS Modules kfskfs/constantskfs/utils Classes BtableReadableFileStreamSbucketWritableFileStream Events ReadableFileStream#event:dataReadableFileStream#event:endReadableFileStream#event:errorReadableFileStream#event:readableSbucket#event:closeSbucket#event:idleSbucket#event:openWritableFileStream#event:errorWritableFileStream#event:finish Tutorials Command Line InterfaceProgrammatic UsagePerformance Testing the Changes Performance Testing the Changes One major hypothesis of this project is that KFS enhances performance over the use a of a standard LevelDB instance. This is due to the nature of how KFS bounds the cost of LevelDB's compaction mechanism by sharding a data set over a series of size-capped LevelDB instances. A set of performance tests were run on a standard LevelDB along with our version which leverages KFS. This is a short summary of our findings and their implications. Experiment DesignA series of one hundred trials were run in sequential order. Each trial consisted of measuring the execution time for a complete read, write, and unlink (delete) operation on file sizes of 8, 16, 32, 64, 128, 256 and 512 MiB. Keeping in mind that files are split into discrete 64KiB key/value pairs, keyed by a hash of the content of the entire file, this means that the actual number of read/write/delete operations are equal to the size of the file divided by 64KiB. Of particular note is that each sequential test run adds approximately 1GiB to the full size of the database (since unlinks only tombstone entries). Our number of trials is consistent with our assertion that LevelDBs performance degrades significantly after the size of the database exceeds 100GiB. This experiment was conducted for both a vanilla (standard) LevelDB and a version using the KFS protocol. All trials used a solid state drive (SSD). ResultsAn overview plot displaying the execution time by file size and operation for each trial indicates some difference between KFS and a vanilla LevelDB. At a high level it appears vanilla LevelDB had a higher variance across many categories. It is our belief that this variance is due to compaction triggering in LevelDB as the size of the single instance grows quickly. Since data is spread in a uniform fashion across a series of LevelDBs in KFS, this compaction triggering happens less frequently and has a much smaller impact. Upon closer inspection the data shows that in every category the mean execution time is lower for KFS for all categories. As for variance, vanilla LevelDB is vastly greater than KFS for writes and unlinks but more consistent for reads. Running two sided significant tests on each combination of operation and file size provides P-Values at the 95% confidence level or higher. This indicates that our measurements are not the result of a statistical fluke and KFS introduces meaningful change. ConclusionWhile P-Values should not be followed blindly, the data does indicate that the KFS protocol gives statistically significant gains in speed and consistency. × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
